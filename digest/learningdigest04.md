# 02-RUST Virtual Machine Learning

## 今日学习总结

> 当前北京时间：2024 年 09 月 14 日 23:47:33

### 进度

- [x] build_vm_part_17.md
- [x] build_vm_part_18.md

### 笔记

**关于输入输出流在单元测试中的问题**

今天在学习过程中，的确看到了一个问题：如何在测试中确保输出的内容就是 想要的字符/字符串呢？
我记得在最开始学习 rust 的时候，在 rust bible, rust 圣经里有说; 使用 write trait 来实现输出功能，就能够更方便的测试。

但是，在实际项目中，这种情况，比如 println!, print! 输出文字时是在整个函数的中间部分，而不能作为整个函数调用的返回部分..
例如：

```rust
fn main() {
    // <snip> 
    if let Some(name) = abc()
    {
        println!("{}",name);
    }
    // <snip>
}

```

那么则没有办法直接将 `name` 这个字符串保留下来，进而直接判断。
该如何截取 stdin, stdout 这部分输入输出流才是正确的办法吧。但是我还不知道该如何处理，以后找一找解决办法，加一个中间层。

```text
-----------------------------         ---------------------------------------           -----------------------------
|                           |         |          |              |           |           |                           |
|      stdin 用户输入       |  ---->  |  输入流  |   程序处理   |   输出流  |  ---->    |        stdout 输出        | 
|                           |         |   拦截   |              |    拦截   |           |                           |
----------------------------          ---------------------------------------           ----------------------------
```

关于 VM 架构和思考

1. Opcode 和 Directive 的区别
    1. Opcode 是指在虚拟机中，对内存的操作，例如：MOV, ADD, SUB, MUL, DIV 等等。表示具体机器指令的操作码，可以直接被执行。
    2. Directive 是指在虚拟机中，对虚拟机自身进行操作，例如：LOAD, SAVE, CALL, RETURN 等等。用来指示汇编器如何处理源代码的伪指令，不会被执行，而是在汇编阶段被处理。
好的，让我们详细探讨一下 `Opcode`（操作码）和 `Directive`（伪指令/指令）之间的区别。这两个术语虽然在某些上下文中可能会有重叠，但在大多数情况下它们有着明确的不同意义。

### Opcode（操作码）

操作码（Opcode）是指在机器语言中用来标识特定操作的代码。它是 CPU 指令集中的一部分，表示了一条具体的机器指令。在汇编语言中，操作码通常由助记符表示，例如 `MOV`、`ADD`、`JMP` 等。

#### 特点

1. **直接映射到硬件操作**：操作码直接对应处理器上的物理操作，如移动数据、执行算术运算、跳转等。
2. **可执行性**：操作码是一条可以直接被执行的指令。
3. **助记符表示**：在汇编语言中，操作码通常用助记符表示，便于程序员理解和编写。
4. **操作数**：操作码通常带有一个或多个操作数，这些操作数指定了操作的对象或地址。

#### 示例

假设一个简单的虚拟机，其中包含以下操作码：

- `LOAD`: 从内存加载一个值到寄存器。
- `STORE`: 将寄存器中的值存储到内存。
- `ADD`: 将两个寄存器的值相加并存入另一个寄存器。

在汇编语言中，这些操作码可能表示为：

```assembly
LOAD $1 #0
ADD $1 $2 $3
SUB $2 $3 $1
```

### Directive（伪指令/指令）

伪指令（Directive）并不是真正的机器指令，而是在汇编过程中用来控制汇编器行为的命令。伪指令主要用于提供元信息，如定义变量、分配内存、引入外部文件等。

#### 特点

1. **与硬件无关**：伪指令在汇编阶段处理，不直接映射到任何特定的硬件操作。
2. **非可执行性**：伪指令本身不会被执行，而是用来改变汇编器的行为。
3. **助记符表示**：伪指令通常也有助记符表示，但这些助记符不是用来直接执行的。
4. **控制汇编过程**：伪指令用来控制汇编过程，如文件包含、宏定义等。

#### 示例

假设一个简单的虚拟机，其中包含以下伪指令：

- `EQU`: 定义一个常量。
- `ORG`: 设置汇编起始地址。
- `DB`: 分配内存并初始化字节。
- `DW`: 分配内存并初始化字。

在汇编语言中，这些伪指令可能表示为：

```assembly
EQU START_ADDR 0x1000  ; 定义常量 START_ADDR
ORG $START_ADDR        ; 设置汇编起始地址为 START_ADDR
DB 'Hello, World!'     ; 分配内存并初始化字符串 "Hello, World!"
DW 0x1234              ; 分配内存并初始化一个16位数 0x1234
```

可以说伪指令提供了高层次的控制和描述，而操作码实现了这些描述的具体功能。

伪指令在汇编阶段被处理成相应的数据和符号定义，而操作码则被翻译成最终执行的机器码。
